<!DOCTYPE html>
<html>
<head>
    <title>MediaMonit - Monitor Mediów</title>
    <style>
        :root {
            --primary: #0f172a;
            --success: #10b981;
            --error: #ef4444;
            --warning: #f59e0b;
            --border: #e2e8f0;
            --bg-light: #f8fafc;
            --text-dark: #1e293b;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: var(--text-dark);
            background: var(--bg-light);
            padding: 2rem;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            color: var(--primary);
            margin-bottom: 2rem;
            font-size: 2rem;
            border-bottom: 2px solid var(--border);
            padding-bottom: 0.5rem;
        }

        .media-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
        }

        .media-card {
            background: white;
            border-radius: 0.75rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .media-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .media-preview {
            height: 200px;
            background: var(--primary);
            position: relative;
            overflow: hidden;
        }

        .media-preview img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: opacity 0.3s ease;
        }

        .media-preview.loading::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(
                    90deg,
                    rgba(255, 255, 255, 0) 0%,
                    rgba(255, 255, 255, 0.2) 50%,
                    rgba(255, 255, 255, 0) 100%
            );
            animation: shimmer 1.5s infinite;
        }

        @keyframes shimmer {
            0% {
                transform: translateX(-100%);
            }
            100% {
                transform: translateX(100%);
            }
        }

        .media-info {
            padding: 1rem;
        }

        .media-title {
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .media-link {
            color: inherit;
            text-decoration: none;
        }

        .media-status {
            font-size: 0.875rem;
            padding: 0.5rem;
            border-radius: 0.5rem;
            margin-top: 0.5rem;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .media-status.active {
            background-color: rgba(16, 185, 129, 0.1);
            color: var(--success);
        }

        .media-status.error {
            background-color: rgba(239, 68, 68, 0.1);
            color: var(--error);
        }

        .media-status.warning {
            background-color: rgba(245, 158, 11, 0.1);
            color: var(--warning);
        }

        .media-metadata {
            font-size: 0.875rem;
            color: #64748b;
            margin-top: 0.5rem;
        }

        .media-metadata dl {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 0.25rem 0.75rem;
        }

        .media-metadata dt {
            font-weight: 500;
        }

        .media-metadata dd {
            color: #94a3b8;
        }

        .text-preview {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875rem;
            padding: 0.75rem;
            background: #f1f5f9;
            border-radius: 0.5rem;
            margin-top: 0.5rem;
            max-height: 100px;
            overflow-y: auto;
            white-space: pre-wrap;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 0.5rem;
            transition: background-color 0.3s ease;
        }

        .status-indicator.active {
            background-color: var(--success);
        }

        .status-indicator.error {
            background-color: var(--error);
        }

        .status-indicator.warning {
            background-color: var(--warning);
        }

        .media-preview {
            height: 200px;
            background: #1e293b;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .media-preview img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            transition: opacity 0.3s ease;
            background: #0f172a;
        }

        .media-preview.error::before {
            content: 'Błąd generowania podglądu';
            color: white;
            font-size: 0.875rem;
            position: absolute;
        }

        .media-preview.loading::before {
            content: 'Generowanie podglądu...';
            color: white;
            font-size: 0.875rem;
            position: absolute;
        }

        .debug-info {
            font-family: monospace;
            font-size: 0.75rem;
            padding: 0.5rem;
            background: #f1f5f9;
            border-radius: 0.25rem;
            margin-top: 0.5rem;
            display: none;
        }

        .media-card:hover .debug-info {
            display: block;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>MediaMonit - Monitor Mediów</h1>


    <div class="media-links">
        <div>
            <a href="rtsp://test1234:test1234@192.168.188.225:554/Preview_01_sub" >
                Stream RTSP #1
            </a>
        </div>

        <div>
            <a href="rtmp://localhost:9000/stream2">
                Stream RTMP #2
            </a>
        </div>

        <div>
            <a href="http://localhost:9000/stream3/playlist.m3u8">
                Stream HLS #3
            </a>
        </div>

        <div>
            <a href="http://localhost:9000/stream4/manifest.mpd">
                Stream DASH #4
            </a>
        </div>

        <div>
            <a href="http://localhost:9000/media/video.mp4">
                Plik MP4 #5
            </a>
        </div>
        <div>
            <a href="http://localhost:9000/media/watermark.gif">
                Plik MP4 #5
            </a>
        </div>
        <div>
            <a href="http://localhost:9000/media/watermark.png">
                Plik MP4 #5
            </a>
        </div>
        <div>
            <a href="http://localhost:9000/document.txt">
                Plik tekstowy #6
            </a>
        </div>

        <div>
            <a href="http://localhost:9000/mediamonit.md">
                Plik tekstowy #6
            </a>
        </div>

        <div>
            <a href="http://localhost:9000/index.html">
                Strona HTML #7
            </a>
        </div>
    </div>

    <div class="media-grid" id="mediaGrid">
        <!-- Media cards will be inserted here dynamically -->
    </div>
</div>

<script>
    class MediaMonitor {
        constructor(options = {}) {
            this.options = {
                interval: options.interval || 300,
                gridElement: options.gridElement || document.getElementById('mediaGrid'),
                baseUrl: options.baseUrl || 'http://localhost:3000',
                debug: options.debug || false
            };

            this.mediaCards = new Map();

            // Definicje typów mediów i ich rozszerzeń
            this.mediaTypes = {
                video: ['mp4', 'webm', 'mov', 'avi'],
                stream: {
                    rtsp: ['rtsp://'],
                    rtmp: ['rtmp://'],
                    hls: ['.m3u8', 'playlist.m3u8'],
                    dash: ['.mpd', 'manifest.mpd']
                },
                image: ['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg'],
                text: ['txt', 'md'],
                html: ['html', 'htm']
            };

            this.init();
        }

        detectMediaType(url) {
            // Usuń parametry z URL
            const cleanUrl = url.split('?')[0].toLowerCase();
            const extension = cleanUrl.split('.').pop();

            // Sprawdź protokoły strumieniowania
            if (cleanUrl.startsWith('rtsp://')) return 'rtsp';
            if (cleanUrl.startsWith('rtmp://')) return 'rtmp';

            // Sprawdź specjalne przypadki HLS i DASH
            if (cleanUrl.includes('playlist.m3u8') || cleanUrl.endsWith('.m3u8')) return 'hls';
            if (cleanUrl.includes('manifest.mpd') || cleanUrl.endsWith('.mpd')) return 'dash';

            // Sprawdź rozszerzenia plików
            if (this.mediaTypes.video.includes(extension)) return 'video';
            if (this.mediaTypes.image.includes(extension)) return 'image';
            if (this.mediaTypes.text.includes(extension)) return 'text';
            if (this.mediaTypes.html.includes(extension)) return 'html';

            // Jeśli nie rozpoznano typu, spróbuj zgadnąć na podstawie ścieżki
            if (cleanUrl.includes('/media/')) return 'video';
            if (cleanUrl.includes('/stream')) return 'stream';

            return 'unknown';
        }

        init() {
            const mediaLinks = document.querySelectorAll('.media-links a');
            mediaLinks.forEach(link => {
                const url = link.href;
                const detectedType = this.detectMediaType(url);

                // Ustaw lub zaktualizuj atrybut data-media-type
                link.setAttribute('data-media-type', detectedType);

                // Zaktualizuj tekst linku jeśli tytuł jest niepoprawny
                if (link.textContent.includes('Plik MP4') && detectedType !== 'video') {
                    link.textContent = `${this.getTypeName(detectedType)} #${this.getUniqueId()}`;
                }

                this.createMediaCard(link);
            });
            this.startMonitoring();
        }

        getTypeName(type) {
            const typeNames = {
                'rtsp': 'Stream RTSP',
                'rtmp': 'Stream RTMP',
                'hls': 'Stream HLS',
                'dash': 'Stream DASH',
                'video': 'Plik Video',
                'image': 'Obraz',
                'text': 'Plik tekstowy',
                'html': 'Strona HTML',
                'unknown': 'Nieznany typ'
            };
            return typeNames[type] || 'Nieznany typ';
        }

        // Generator unikalnych ID
        getUniqueId() {
            if (!this.lastId) this.lastId = 0;
            return ++this.lastId;
        }

        createMediaCard(link) {
            const card = document.createElement('div');
            card.className = 'media-card';

            const url = link.href;
            const type = link.getAttribute('data-media-type');
            const title = link.textContent.trim();

            card.innerHTML = `
                    <div class="media-preview loading" data-url="${url}" data-type="${type}">
                        <img src="" alt="${title}" style="opacity: 0">
                    </div>
                    <div class="media-info">
                        <h2 class="media-title">
                            <span class="status-indicator"></span>
                            <a href="${url}" class="media-link" target="_blank">${title}</a>
                        </h2>
                        <div class="media-status">Sprawdzanie...</div>
                        <div class="media-metadata">
                            <dl>
                                <dt>Typ:</dt>
                                <dd>${type.toUpperCase()}</dd>
                                <dt>URL:</dt>
                                <dd>${new URL(url).pathname}</dd>
                            </dl>
                        </div>
                        <div class="debug-info"></div>
                    </div>
                `;

            this.options.gridElement.appendChild(card);
            this.mediaCards.set(url, {
                element: card,
                type: type,
                lastCheck: 0,
                thumbnailRetries: 0
            });
        }

        async checkStatus(url, type) {
            try {
                const response = await fetch(`${this.options.baseUrl}/check-status`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({url, type})
                });
                return await response.json();
            } catch (error) {
                return {
                    status: 'error',
                    message: error.message
                };
            }
        }

        async updateThumbnail(url, type, previewElement, mediaInfo) {
            try {
                // Dla plików tekstowych nie generujemy miniatury
                if (['txt', 'md', 'html'].includes(type.toLowerCase())) {
                    previewElement.classList.remove('loading');
                    return;
                }

                // Dla obrazów wyświetlamy bezpośrednio
                if (['jpg', 'jpeg', 'png', 'gif', 'webp'].includes(type.toLowerCase())) {
                    const imgElement = previewElement.querySelector('img');
                    imgElement.src = url;
                    imgElement.style.opacity = '1';
                    previewElement.classList.remove('loading');
                    previewElement.classList.remove('error');
                    return;
                }

                // Dla video i streamów generujemy miniaturę
                if (mediaInfo.thumbnailRetries > 3) {
                    previewElement.classList.remove('loading');
                    previewElement.classList.add('error');
                    return;
                }

                const response = await fetch(`${this.options.baseUrl}/generate-thumbnail`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({url, type})
                });

                const data = await response.json();

                if (this.options.debug) {
                    const debugInfo = previewElement.parentElement.querySelector('.debug-info');
                    debugInfo.textContent = JSON.stringify({thumbnailResponse: data}, null, 2);
                }

                if (data.thumbnailUrl) {
                    const imgElement = previewElement.querySelector('img');
                    const newImage = new Image();

                    newImage.onload = () => {
                        imgElement.src = newImage.src;
                        imgElement.style.opacity = '1';
                        previewElement.classList.remove('loading');
                        previewElement.classList.remove('error');
                        mediaInfo.thumbnailRetries = 0;
                    };

                    newImage.onerror = () => {
                        mediaInfo.thumbnailRetries++;
                        previewElement.classList.add('error');
                        if (this.options.debug) {
                            console.error('Error loading thumbnail:', data.thumbnailUrl);
                        }
                    };

                    const thumbnailUrl = data.thumbnailUrl.startsWith('http')
                        ? data.thumbnailUrl
                        : this.options.baseUrl + data.thumbnailUrl;

                    newImage.src = thumbnailUrl + '?t=' + Date.now();
                } else {
                    mediaInfo.thumbnailRetries++;
                    previewElement.classList.add('error');
                }
            } catch (error) {
                mediaInfo.thumbnailRetries++;
                previewElement.classList.add('error');
                if (this.options.debug) {
                    console.error('Error updating thumbnail:', error);
                    const debugInfo = previewElement.parentElement.querySelector('.debug-info');
                    debugInfo.textContent = JSON.stringify({thumbnailError: error.message}, null, 2);
                }
            }
        }

        updateCardStatus(card, status) {
            const statusIndicator = card.querySelector('.status-indicator');
            const statusElement = card.querySelector('.media-status');
            const metadataElement = card.querySelector('.media-metadata');
            const debugInfo = card.querySelector('.debug-info');

            // Update status classes
            statusIndicator.className = `status-indicator ${status.status}`;
            statusElement.className = `media-status ${status.status}`;
            statusElement.textContent = status.message;

            // Update metadata if available
            if (status.metadata) {
                const metadataHtml = Object.entries(status.metadata)
                    .map(([key, value]) => `
                            <dt>${key}:</dt>
                            <dd>${value}</dd>
                        `).join('');

                metadataElement.querySelector('dl').innerHTML = metadataHtml;
            }

            // Add preview for text/html content
            if (status.preview) {
                const existingPreview = card.querySelector('.text-preview');
                if (!existingPreview) {
                    const previewElement = document.createElement('div');
                    previewElement.className = 'text-preview';
                    card.querySelector('.media-info').appendChild(previewElement);
                }
                card.querySelector('.text-preview').textContent = status.preview;
            }

            // Update debug info
            if (this.options.debug) {
                debugInfo.textContent = JSON.stringify(status, null, 2);
            }
        }

        shouldGenerateThumbnail(type) {
            // Sprawdź czy typ wymaga generowania miniatury
            const requiresThumbnail = [...this.mediaTypes.video, ...this.mediaTypes.stream, ...this.mediaTypes.image];
            return requiresThumbnail.includes(type.toLowerCase());
        }

        async checkMedia(url, mediaInfo) {
            const status = await this.checkStatus(url, mediaInfo.type);
            this.updateCardStatus(mediaInfo.element, status);

            const type = mediaInfo.type.toLowerCase();
            const previewElement = mediaInfo.element.querySelector('.media-preview');

            if (status.status === 'active') {
                if (['txt', 'md', 'html'].includes(type)) {
                    // Dla plików tekstowych ukrywamy preview
                    previewElement.style.display = 'none';
                } else if (this.shouldGenerateThumbnail(type)) {
                    // Dla mediów i obrazów generujemy/wyświetlamy podgląd
                    await this.updateThumbnail(url, type, previewElement, mediaInfo);
                }
            }
        }

        startMonitoring() {
            setInterval(() => {
                const now = Date.now();
                this.mediaCards.forEach((mediaInfo, url) => {
                    if (now - mediaInfo.lastCheck >= this.options.interval) {
                        this.checkMedia(url, mediaInfo);
                        mediaInfo.lastCheck = now;
                    }
                });
            }, this.options.interval);
        }
    }

    // Initialize the monitor with debug mode
    const monitor = new MediaMonitor({
        interval: 1900,
        baseUrl: 'http://localhost:3000',
        debug: true // Włącz tryb debug
    });
</script>
</body>
</html>
